


PERSISTENCE

Overview:

    VIEWS <=> MODEL/NODES <=> NODESTORE <=> SYNCDB <=> INDEXEDDB

By subclassing BMStorableNode and calling the following methods in your subclasses init method, the object will be automatically stored and loaded as needed.

 	this.setShouldStore(true)
 	
To enable/disable whether subnodes are stored, call:
 	
 	this.setShouldStoreSubnodes(abool)
 	
And to declare which slots should be persisted, call:

    this.addStoredSlot("[the slot name]")
    
When subclasses of Proto update a slot defined by calling the: 

    this.newSlot() or this.newSlots()
    
methods (which creates getters and setters for each slot), it will call:

    this.didUpdateSlot()
    
BMStorableNode overrides the didUpdateSlot() method to call:

    this.scheduleSyncToStore() 
    
which will add the object to the NodeStore's dirty object list. On the next event loop, NodeStore will:

	1) Begins a SyncDB transaction.
	
	2) Write all dirty nodes to SyncDB transaction.
	   It checks the stored slots of each dirty object for unpersisted references.
	   If found, it will marked those objects as dirty as well. 
	   
	3) Commits the SyncDB transaction, which bundles these write requests into a single IndexedDB transaction "commit".
	   An IndexedDB tx commit just means that if it doesn't abort the tx before the end of the event loop, 
	   then it will be atomically written.
	
SYNCDB

SyncDB is a layer over IndexedDB designed to provide a synchronous API (as IndexedDB's API is async only) via:

    - a read cache
    - a transactional write cache
    
On startup, SyncDB reads all data from IndexedDB into it's read cache. Reads will only access this read cache, but first check the write cache for changes. After a commit, SyncDB updates it's read cache with any changes in the write cache and then clears it's write cache.
These low level SyncDB APIs aren't accessed directly but are handled automatically via the NodeStore object. 

