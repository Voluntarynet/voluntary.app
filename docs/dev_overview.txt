
APP OVERVIEW

This app started as a port of Bitmarkets Objective-C/OSX implementation to Electron/Javascript in order to support the app across platforms. Bitmarkets is a sort of decentralized ebay that uses Bitcoin for decentralized transactions, Bitmessage for decentralized and secure communications, and 2 party escrow to secure transctions:

    https://voluntary.net/bitmarkets/
    
I made progress on re-implementing Bitmarket's Miller column based UI and replacing Bitmessage with a webRTC based messaging system but ran into issues with getting a Bitcoin wallet working in JS (e.g. state of stand alone JS Bitcoin implementations). Around this time, I heard about Mastadon (a federated Twitter clone) getting traction and decided it might be worth releasing a decentralized twitter-like app using the existing code first.

FRAMEWORKS

The app is built on integrated naked objects UI and transparent persistence database frameworks. 
These allow the developer to add new business/model level objects without the need to write (almost) any code to interface these objects to the UI or DB. 

BASICS

The system is built around the observations: 
    - typically, there's a close correspondence between data, model, and view objects 
    - the structure of the data, model and views can each be well described as hierarchy (with links)
    - synchronization between data, model and views can be generalized
	- an expanding miller column like UI can be generalized to work reactively on most devices
	- form entry and it's mapping to model and data objects can be generalized for most use cases
	

HOW TO USE

Model level objects should subclass the BMNode class. 
If the object will need to persist itself, it should subclass BMStorableNode.

HOW IT WORKS


DATABASE

By subclassing BMStorableNode and calling this.addStoredSlot("slotName"), the object and specified slots will be automatically stored and loaded as needed.

All data is stored underneath using client side IndexedDB. As IndexedDB only supports an async API, a SyncDB wrapper object is used to provide a sync API. On startup, SyncDB reads all data from IndexedDB into it's read cache.

SyncDB has a transactional write cache (reads check the write cache before reading from SyncDB's own cache). These low level APIs aren't accessed directly but are handled automatically via the NodeStore object. BMStorableNode's have stored slots which, when modified, mark the object as "dirty" (as needing to be flushed to disk) and inform the NodeStore to add them to it's dirty objects list. On the next event loop, the NodeStore will:

	1) begin a SyncDB transaction 
	2) write all dirty nodes to SyncDB's write cache 
	3) commits the SyncDB transaction, which bundles these writes into a single IndexedDB transaction 
	and "commits" it (which just means it doesn't abort it before the end of the event loop).
	
